/*
  Tic-Tac-Toe (2-player) for Arduino Uno + 20x4 I2C LCD + 4x4 Keypad
  From your project PDF:
  - Keypad pins 1-8 -> Arduino D2-D9
  - I2C LCD:
      SDA -> A4
      SCL -> A5
      VCC -> 5V
      GND -> GND
  Controls:
  - Press 1..9 to place mark in that cell
  - Press # to reset anytime
  Libraries needed (install via Arduino Library Manager):
  - "Keypad" by Mark Stanley, Alexander Brevig
  - "LiquidCrystal I2C" (common variants work; this sketch uses LiquidCrystal_I2C.h)
*/
#include <Wire.h>
#include <Keypad.h>
#include <LiquidCrystal_I2C.h>
// Many 20x4 I2C LCD backpacks use 0x27; some use 0x3F.
// If your LCD shows nothing, try changing to 0x3F.
static const uint8_t LCD_ADDR = 0x27;
static const uint8_t LCD_COLS = 20;
static const uint8_t LCD_ROWS = 4;
LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);
// 4x4 keypad wiring: pins 1-8 to D2-D9 (rows then cols)
static const byte ROWS = 4;
static const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1', '2', '3', 'A'},
  {'4', '5', '6', 'B'},
  {'7', '8', '9', 'C'},
  {'*', '0', '#', 'D'}
};
// Assumption (common): keypad pin order is R1 R2 R3 R4 C1 C2 C3 C4
// With PDF wiring "pins 1-8 -> D2-D9", we map:
// - Rows: D2..D5
// - Cols: D6..D9
byte rowPins[ROWS] = {2, 3, 4, 5};
byte colPins[COLS] = {6, 7, 8, 9};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
char board[9];
char currentPlayer = 'X';
bool gameOver = false;
unsigned long gameOverAtMs = 0;
static const unsigned long AUTO_RESET_MS = 5000;
void resetGame();
void drawBoard();
bool isCellTaken(uint8_t idx);
bool hasWinner(char p);
bool isDraw();
void showStatusLine(const char* msg);
void renderRow(uint8_t lcdRow, uint8_t baseIdx);
void setup() {
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Tic-Tac-Toe");
  lcd.setCursor(0, 1);
  lcd.print("1-9 move  #=RST");
  delay(1200);
  resetGame();
}
void loop() {
  // Auto-reset after result
  if (gameOver && (millis() - gameOverAtMs >= AUTO_RESET_MS)) {
    resetGame();
  }
  char k = keypad.getKey();
  if (!k) return;
  if (k == '#') {
    resetGame();
    return;
  }
  if (gameOver) {
    // Ignore moves until reset
    return;
  }
  if (k < '1' || k > '9') {
    // Ignore non-move keys
    return;
  }
  uint8_t idx = (uint8_t)(k - '1');
  if (isCellTaken(idx)) {
    showStatusLine("Taken! Pick another.");
    return;
  }
  board[idx] = currentPlayer;
  drawBoard();
  if (hasWinner(currentPlayer)) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(currentPlayer);
    lcd.print(" wins!");
    lcd.setCursor(0, 1);
    lcd.print("#=reset  auto 5s");
    gameOver = true;
    gameOverAtMs = millis();
    return;
  }
  if (isDraw()) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("It's a tie!");
    lcd.setCursor(0, 1);
    lcd.print("#=reset  auto 5s");
    gameOver = true;
    gameOverAtMs = millis();
    return;
  }
  // Next player
  currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';
  drawBoard();
}
void resetGame() {
  for (uint8_t i = 0; i < 9; i++) {
    board[i] = (char)('1' + i); // show numbers for empty cells
  }
  currentPlayer = 'X';
  gameOver = false;
  gameOverAtMs = 0;
  drawBoard();
}
void drawBoard() {
  lcd.clear();
  // Status row (20 cols)
  lcd.setCursor(0, 0);
  lcd.print("Turn: ");
  lcd.print(currentPlayer);
  lcd.print("   #=RST");
  // Grid rows
  renderRow(1, 0);
  renderRow(2, 3);
  renderRow(3, 6);
}
void renderRow(uint8_t lcdRow, uint8_t baseIdx) {
  lcd.setCursor(0, lcdRow);
  // Format: " 1 | 2 | 3" (or X/O)
  lcd.print(' ');
  lcd.print(board[baseIdx + 0]);
  lcd.print(" | ");
  lcd.print(board[baseIdx + 1]);
  lcd.print(" | ");
  lcd.print(board[baseIdx + 2]);
  // Clear remainder of line if needed
  // Printed width is 10 characters: " " + c + " | " + c + " | " + c
  for (uint8_t i = 0; i < (LCD_COLS - 10); i++) lcd.print(' ');
}
void showStatusLine(const char* msg) {
  // Put message on row 0 temporarily, then redraw after a short pause
  lcd.setCursor(0, 0);
  lcd.print("                    "); // clear 20 chars
  lcd.setCursor(0, 0);
  lcd.print(msg);
  delay(700);
  drawBoard();
}
bool isCellTaken(uint8_t idx) {
  return (board[idx] == 'X' || board[idx] == 'O');
}
bool hasWinner(char p) {
  // 8 winning lines
  const uint8_t w[8][3] = {
    {0, 1, 2}, {3, 4, 5}, {6, 7, 8}, // rows
    {0, 3, 6}, {1, 4, 7}, {2, 5, 8}, // cols
    {0, 4, 8}, {2, 4, 6}             // diagonals
  };
  for (uint8_t i = 0; i < 8; i++) {
    if (board[w[i][0]] == p && board[w[i][1]] == p && board[w[i][2]] == p) {
      return true;
    }
  }
  return false;
}
bool isDraw() {
  for (uint8_t i = 0; i < 9; i++) {
    if (!isCellTaken(i)) return false;
  }
  return true;
}
